#' Calculates the three year average for the PM2.5 24 hour metric
#'
#' Flags if based on only two years.
#' 
#' @import dplyr
#' @param  data data frame containing annual 98th percentile values, most likely
#'              generated by \code{\link{pm_98_percentile}}
#' @param  yearcol column containing the year
#' @param  valcol column containing annual 98th percentile values
#' @param  ... Other grouping variables (such as station id)
#' @param  year The year to calculate the metric for (this will be the latest
#'              of the three years used in the calculation). Can be "latest" to 
#'              use the latest year found in the data frame, or an integer 
#'              denoting the year.
#' @export
#' @seealso \code{\link{pm_98_percentile}}
#' @return a data frame, with year, the value, and the number of years the value
#'         is based on
#' @examples \dontrun{
#' 
#'}
pm_24hr_caaq <- function(data, yearcol, valcol, ..., year = "latest") {
  vars <- list(yearcol, valcol, ...)
  
  for (var in vars) {
    if (!var %in% names(data)) stop(var, " is not a column in data")
  }
  
  if (inherits(year, c("integer","numeric"))) {
    if (!year %in% data[[yearcol]]) stop(year, " does not exist in data")
  } else if (year == "latest") {
    year <- max(data[[yearcol]])
  } else {
    stop("year must be an integer or 'latest'")
  }
  
  if (!inherits(data[[valcol]], "numeric")) {
    stop(valcol, "is not numeric")
  }
  
  years <- seq(to = year, length.out = 3)
  
  rows <- data[data[[yearcol]] %in% years,]
  
  if (length(vars) > 2) {
    dots <- list(...)
    rows <- group_by_(rows, .dots = dots)
  }
  
  caaq_formula <- interp(~ifelse(x >=2, mean(y, na.rm = TRUE), NA_real_), 
                         x = n_years, y = as.name(valcol))
  
  ret <- rows %>%
    summarise_(year         = ~max(year),
               n_years      = ~n(),
               pm_24hr_caaq = caaq_formula)
  ret
  
}
